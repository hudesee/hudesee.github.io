<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://hudesee.github.io</id>
    <title>hudese</title>
    <updated>2020-02-20T10:36:57.441Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://hudesee.github.io"/>
    <link rel="self" href="https://hudesee.github.io/atom.xml"/>
    <subtitle>胡嘚瑟的个人博客</subtitle>
    <logo>https://hudesee.github.io/images/avatar.png</logo>
    <icon>https://hudesee.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, hudese</rights>
    <entry>
        <title type="html"><![CDATA[黄金队列]]></title>
        <id>https://hudesee.github.io/post/huang-jin-dui-lie/</id>
        <link href="https://hudesee.github.io/post/huang-jin-dui-lie/">
        </link>
        <updated>2020-02-01T10:17:24.000Z</updated>
        <content type="html"><![CDATA[<p>第三届蓝桥杯Java组 黄金队列</p>
<p>Description</p>
<p>黄金分割数0.618与美学有重要的关系。舞台上报幕员所站的位置大约就是舞台宽度的0.618处，墙上的画像一般也挂在房间高度的0.618处，甚至股票的波动据说也能找到0.618的影子....</p>
<p>黄金分割数是个无理数，也就是无法表示为两个整数的比值。0.618只是它的近似值，其真值可以通过对5开方减去1再除以2来获得，我们取它的一个较精确的近似值：0.618034</p>
<p>有趣的是，一些简单的数列中也会包含这个无理数，这很令数学家震惊！</p>
<p>1 3 4 7 11 18 29 47 .... 称为“鲁卡斯队列”。它后面的每一个项都是前边两项的和。</p>
<p>如果观察前后两项的比值，即：1/3 3/4 4/7 7/11 11/18 ... 会发现它越来越接近于黄金分割数！</p>
<p>你的任务就是计算出从哪一项开始，这个比值四舍五入后已经达到了与0.618034一致的精度。</p>
<p>请写出该比值。格式是：分子/分母。比如：29/47</p>
<p>Input</p>
<p>没有输入。</p>
<p>Output</p>
<p>输出比值四舍五入后达到了与0.618034一致精度的第一个分式。</p>
<p>这个题需要用高精度的格式来写就需要用到 BigDecimal。<br>
什么是BigDecimal呢？</p>
<ul>
<li></li>
</ul>
<blockquote>
<p>Java在java.math包中提供的API类BigDecimal，用来对超过16位有效位的数进行精确的运算。双精度浮点型变量double可以处理16位有效数。在实际应用中，需要对更大或者更小的数进行运算和处理。float和double只能用来做科学计算或者是工程计算，在商业计算中要用java.math.BigDecimal。BigDecimal所创建的是对象，我们不能使用传统的+、-、*、/等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。方法中的参数也必须是BigDecimal的对象。构造器是类的特殊方法，专门用来创建对象，特别是带有参数的对象。<br>
<strong>以上来源于百度百科</strong></p>
</blockquote>
<ul>
<li></li>
</ul>
<p>这个题呢很简单，仔细观察一下发现和 斐波那契数列 很相似，他们都是有规律的，前一项分子和分母的和等于 后面一项的分母，前一项的分母等于后一项的分子，当发现这个规律之后，这个题就迎刃而解了，只不过需要注意BigDecimal 的用法。</p>
<pre><code class="language-java">import java.math.*;
public class Main
{
	public static void main(String[] args) {
		/*
		 * 分子:numerator 分母:denominator
		 */
		BigDecimal golden = new BigDecimal(&quot;0.618034&quot;);//使用字符串不容易出错
		BigDecimal numerator = new BigDecimal(&quot;1&quot;);
		BigDecimal denominator = new BigDecimal(&quot;3&quot;);
		BigDecimal temp = new BigDecimal(&quot;0&quot;);
		while(true )
		{	
				if (golden.equals(numerator.divide(denominator, 6,BigDecimal.ROUND_HALF_UP ))) {
				break ;
				//BigDecimal.ROUND_HALF_UP  是四舍五入
				
			}
			else {
				
				temp = numerator.add(denominator);
				numerator = denominator;
				denominator = temp;
				
			
			}
			
			
			
		}
		
		System.out.println(numerator+ &quot;/&quot; +denominator);
	}
	
}

</code></pre>
<p>粗略见解，请大家多多指教。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[三角矩阵的压缩矩阵]]></title>
        <id>https://hudesee.github.io/post/san-jiao-ju-zhen-de-ya-suo-ju-zhen/</id>
        <link href="https://hudesee.github.io/post/san-jiao-ju-zhen-de-ya-suo-ju-zhen/">
        </link>
        <updated>2020-01-16T10:43:02.000Z</updated>
        <content type="html"><![CDATA[<p>三角矩阵的压缩矩阵</p>
<p>首先三角矩阵的压缩矩阵<br>
对角线上的元素加上对角线以下的元素，是我们要存储的元素，对角线上面的也是我们要存储的元素，不过他们是相同常数，因此我们可以把这些同样的常数，只要存储一个就可以了。<br>
以上就是下三角矩阵，在一维数组中进行存储，下标k 的公式很好推导，我们利用数学中的等差数列就可以推导出来。(数组中元素最开始的下标为0)</p>
<p>来说一下上三角矩阵，上三角矩阵在一维数组中存储的下<br>
标公式。</p>
<p>在这里插入图片描述<br>
<img src="https://hudesee.github.io/post-images/1579171473625.jpg" alt="" loading="lazy"><br>
出现n 就是为了更好的方便计算，引入i,j是因为二维数组的下标。因为存储二维数组就是把二维数组中的元素存储到一维数组中，因此，i,j在公式中肯定是必不可少的。</p>
<p>粗略见解，请多指教。</p>
]]></content>
    </entry>
</feed>